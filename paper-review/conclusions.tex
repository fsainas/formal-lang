\section{Conclusions}

The careful design of the language allows to prove memory safety properties on all programs that are considered well-typed. The language presented is stated by the authors to be only a subset of the Move language which encompasses its most important features. Basing verification on the bytecode rather than source code allows Move to work in adversarial environments with untrusted code. However, the language is noticeably restricted. To not introduce potential unsafety many conservative decisions have to be made. Authors draw comparison to Rust which validates reference by means of lifetimes by mentioning the benefits of the borrow graph over lifetimes. Yet the drawbacks are not mentioned: lifetimes encode a larger set of executions. To name a few restrictions from which Move suffers from while Rust does not: storing references in records, usage of closures, specifying exact reference relationships. A more restricted language results in awkward workarounds to satisfy the borrow checker and a frustrating programming experience.
