\section{Introduction}

The vast majority of available mainstream programming languages were created without much of consideration of their formal foundation. This makes it difficult to reason about safety guarantees. One can see how that leads to memory errors, unsoundness, and general unsafety of the system. When retrospectively trying to fix such issues, languages are often met with a important decision whether to sacrifice backwards compatibility in return for a safer system. One such great example is the C++ language which has been desperately fighting to be seen as a safe language for many years while being very committed to backwards compatibility of the inherited problems of C. As such, even C++'s creator tries to distance himself from the criticism of C++ being unsafe by saying \textit{``There is no "C/C++ language"''}\cite{bjarne2023}. Only a subset of C programs can be formally proven to be memory safe.

Our goal is to focus on creating a language for which we can formally reason about its properties. That is, the language is defined in terms of its properties which guarantee safety of all programs written in the language, not only a subset of them. While there exist languages which have very strong memory safety guarantees such as \texttt{unsafe}-free Rust for which the memory model has been formally proven to be correct\cite{10.1145/3158154}, these formal proofs do not relate to the real implementation of the language in any way. Our approach will differ in the way that the proofs will be conducted on the implementation of the language rather than some abstract model of it. This gives additional guarantees of the absence of bugs (human errors), assuming the properties have been stated properly.

Since functional languages have been studied a lot and the real world is messy, in this report we define a toy imperative programming language with semantics that allow us to formally show that the implementation of it given some properties (Sec. \ref{sec:properties}) follows an error-free execution. As a backing paper we used the formal definition of the static analysis of the Move language\cite{blackshear2022borrow} which concerns itself with memory safety issues. It too however proves things on an abstract model rather than the implementation.

We start by defining the language, its properties, how we approached the implementation, and conclude with a discussion of how far we got and what challenges we have faced.
